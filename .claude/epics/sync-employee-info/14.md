---
name: Service layer - Employee sync, CRUD, and search operations
status: open
created: 2026-01-09T02:15:19Z
updated: 2026-01-09T02:28:23Z
github: https://github.com/PATCoder97/fhs-prosight/issues/14
depends_on: [12, 13]
parallel: false
conflicts_with: []
---

# Task: Service layer - Employee sync, CRUD, and search operations

## Description

Implement the employee service layer with 7 core methods: single sync from HRS, single sync from COVID, unified bulk sync, search with filters, and CRUD operations (get, update, delete). This layer orchestrates between integration clients and database, handles data mapping, error handling, and transaction management.

**Key Methods:**
1. `sync_employee_from_hrs()` - Single sync from HRS API
2. `sync_employee_from_covid()` - Single sync from COVID API
3. `bulk_sync_employees()` - Unified bulk sync (both sources)
4. `search_employees()` - Search with filters
5. `get_employee_by_id()` - Get single employee
6. `update_employee()` - Update employee data
7. `delete_employee()` - Delete employee

## Acceptance Criteria

### Sync Methods
- [ ] `sync_employee_from_hrs(db, emp_id: int) -> Employee`
  - Fetch từ FHSHRSClient
  - Map 22 fields to Employee model
  - Upsert: if exists update, else create
  - Commit transaction
  - Return Employee object
  - Raise HTTPException on API error

- [ ] `sync_employee_from_covid(db, emp_id: int, token: str) -> Employee`
  - Fetch từ FHSCovidClient with token
  - Map fields to Employee model
  - Merge with existing data (don't overwrite HRS fields)
  - Upsert to database
  - Commit transaction
  - Return Employee object
  - Raise HTTPException on API/token error

- [ ] `bulk_sync_employees(db, from_id, to_id, source, token?) -> Dict`
  - If source=="hrs": call hrs_client.bulk_get_employees()
  - If source=="covid": call covid_client.bulk_get_users()
  - For each result: map to Employee and upsert
  - Continue on individual failures (don't stop batch)
  - Commit after each successful sync
  - Collect results: {total, success, failed, skipped, errors[]}
  - Return summary dict

### Search & CRUD Methods
- [ ] `search_employees(db, name, dept_code, dorm_id, skip, limit) -> List[Employee]`
  - Build query with filters:
    - name: ILIKE on name_tw OR name_en
    - department_code: exact match
    - dorm_id: exact match
  - Apply pagination: offset(skip).limit(limit)
  - Order by: id ASC
  - Return list of Employee objects

- [ ] `get_employee_by_id(db, emp_id: str) -> Optional[Employee]`
  - Query by primary key
  - Return Employee or None

- [ ] `update_employee(db, emp_id, update_data: Dict) -> Employee`
  - Get employee by ID
  - Update fields from dict
  - Validate data
  - Cannot update id (primary key)
  - Set updated_at timestamp
  - Commit
  - Return updated Employee

- [ ] `delete_employee(db, emp_id: str) -> bool`
  - Delete by primary key
  - Return True if deleted, False if not found

## Technical Details

### Service Implementation

```python
# app/services/employee_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, or_
from typing import Optional, Dict, List
from fastapi import HTTPException, status

from app.models.employee import Employee
from app.integrations import FHSHRSClient, FHSCovidClient
from app.schemas.employees import BulkSyncResponse
import logging

logger = logging.getLogger(__name__)

hrs_client = FHSHRSClient()
covid_client = FHSCovidClient()


async def sync_employee_from_hrs(db: AsyncSession, emp_id: int) -> Employee:
    """Sync single employee from HRS API"""
    # Fetch from API
    emp_data = await hrs_client.get_employee_info(emp_id)
    if not emp_data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Employee {emp_id} not found in HRS API"
        )

    emp_id_str = emp_data["employee_id"]

    # Check if exists
    existing = await db.get(Employee, emp_id_str)

    if existing:
        # Update
        logger.info(f"Updating employee: {emp_id_str}")
        for key, value in _map_hrs_to_model(emp_data).items():
            setattr(existing, key, value)
        employee = existing
    else:
        # Create
        logger.info(f"Creating employee: {emp_id_str}")
        employee = Employee(**_map_hrs_to_model(emp_data))
        db.add(employee)

    await db.commit()
    await db.refresh(employee)
    return employee


async def sync_employee_from_covid(
    db: AsyncSession,
    emp_id: int,
    token: str
) -> Employee:
    """Sync single employee from COVID API"""
    emp_data = await covid_client.get_user_info(emp_id, token)
    if not emp_data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Employee {emp_id} not found in COVID API"
        )

    emp_id_str = emp_data["userName"]
    existing = await db.get(Employee, emp_id_str)

    if existing:
        # Merge (don't overwrite HRS fields)
        logger.info(f"Updating employee from COVID: {emp_id_str}")
        covid_fields = _map_covid_to_model(emp_data)
        for key, value in covid_fields.items():
            if value is not None:  # Only update non-null values
                setattr(existing, key, value)
        employee = existing
    else:
        logger.info(f"Creating employee from COVID: {emp_id_str}")
        employee = Employee(**_map_covid_to_model(emp_data))
        db.add(employee)

    await db.commit()
    await db.refresh(employee)
    return employee


async def bulk_sync_employees(
    db: AsyncSession,
    from_id: int,
    to_id: int,
    source: str,
    token: Optional[str] = None
) -> Dict:
    """Unified bulk sync from HRS or COVID"""
    total = to_id - from_id + 1
    success_count = 0
    failed_count = 0
    skipped_count = 0
    errors = []

    # Fetch bulk data
    if source == "hrs":
        results = await hrs_client.bulk_get_employees(from_id, to_id)
    elif source == "covid":
        if not token:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Token required for COVID source"
            )
        results = await covid_client.bulk_get_users(from_id, to_id, token)
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid source: {source}"
        )

    # Process each result
    for idx, result in enumerate(results):
        emp_id = from_id + idx

        if result is None:
            # Skipped (no data from API)
            skipped_count += 1
            continue

        try:
            # Map and upsert
            emp_id_str = result.get("employee_id") or result.get("userName")
            existing = await db.get(Employee, emp_id_str)

            if source == "hrs":
                mapped_data = _map_hrs_to_model(result)
            else:
                mapped_data = _map_covid_to_model(result)

            if existing:
                for key, value in mapped_data.items():
                    if value is not None:
                        setattr(existing, key, value)
            else:
                employee = Employee(**mapped_data)
                db.add(employee)

            await db.commit()
            success_count += 1

        except Exception as e:
            failed_count += 1
            errors.append({
                "emp_id": emp_id,
                "error": str(e)
            })
            logger.error(f"Failed to sync {emp_id}: {e}")
            await db.rollback()

    return {
        "total": total,
        "success": success_count,
        "failed": failed_count,
        "skipped": skipped_count,
        "errors": errors
    }


async def search_employees(
    db: AsyncSession,
    name: Optional[str] = None,
    department_code: Optional[str] = None,
    dorm_id: Optional[str] = None,
    skip: int = 0,
    limit: int = 100
) -> List[Employee]:
    """Search employees with filters"""
    query = select(Employee)

    if name:
        search_term = f"%{name}%"
        query = query.where(
            or_(
                Employee.name_tw.ilike(search_term),
                Employee.name_en.ilike(search_term)
            )
        )

    if department_code:
        query = query.where(Employee.department_code == department_code)

    if dorm_id:
        query = query.where(Employee.dorm_id == dorm_id)

    query = query.offset(skip).limit(limit).order_by(Employee.id)

    result = await db.execute(query)
    return result.scalars().all()


async def get_employee_by_id(
    db: AsyncSession,
    emp_id: str
) -> Optional[Employee]:
    """Get employee by ID"""
    return await db.get(Employee, emp_id)


async def update_employee(
    db: AsyncSession,
    emp_id: str,
    update_data: Dict
) -> Employee:
    """Update employee"""
    employee = await db.get(Employee, emp_id)
    if not employee:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Employee {emp_id} not found"
        )

    # Update fields
    for key, value in update_data.items():
        if key != "id" and hasattr(employee, key):
            setattr(employee, key, value)

    await db.commit()
    await db.refresh(employee)
    return employee


async def delete_employee(
    db: AsyncSession,
    emp_id: str
) -> bool:
    """Delete employee"""
    employee = await db.get(Employee, emp_id)
    if not employee:
        return False

    await db.delete(employee)
    await db.commit()
    return True


# Helper functions
def _map_hrs_to_model(data: Dict) -> Dict:
    """Map HRS API response to Employee model fields"""
    return {
        "id": data["employee_id"],
        "name_tw": data["chinese_name"],
        "name_en": data["vietnamese_name"],
        "dob": data["date_of_birth"],
        "start_date": data["date_of_joining"],
        "dept": data["department"],
        "job_title": data["position"],
        "salary": data["basic_salary"],
        "address1": data["current_address"],
        "address2": data["household_registration"],
        "phone1": data["phone_1"],
        "phone2": data["phone_2"],
        "spouse_name": data["spouse_name"],
        # ... map all fields
    }


def _map_covid_to_model(data: Dict) -> Dict:
    """Map COVID API response to Employee model fields"""
    return {
        "id": data["userName"],
        "name_tw": data["fullName"],
        "department_code": data["departmentCode"],
        "sex": data["sex"],
        "identity_number": data["identityNumber"],
        "nationality": data["nationality"],
        # COVID has fewer fields than HRS
    }
```

### Files to Create

1. `app/services/employee_service.py` - All 7 service methods

## Dependencies

- [x] Task 12: Employee model, schemas
- [x] Task 13: Integration clients
- [x] Database session available (AsyncSession)

## Effort Estimate

- **Size:** L (Large)
- **Hours:** 8-10 hours
  - 2h: sync_employee_from_hrs()
  - 2h: sync_employee_from_covid()
  - 3h: bulk_sync_employees() (complex logic)
  - 1h: search_employees()
  - 2h: CRUD methods (get, update, delete)
  - 1h: Testing all methods
- **Parallel:** false (depends on 12 and 13)

## Definition of Done

- [ ] All 7 methods implemented
- [ ] Error handling: HTTPException raised appropriately
- [ ] Logging: all operations logged with context
- [ ] Transaction management: commit/rollback correctly
- [ ] Bulk sync continues on individual failures
- [ ] Bulk sync returns detailed summary
- [ ] Search filters work correctly (name, dept, dorm)
- [ ] Upsert logic works (create vs update)
- [ ] Tested with mock database session
- [ ] Tested with real integration clients
- [ ] Code follows existing service layer pattern (auth_service.py)
