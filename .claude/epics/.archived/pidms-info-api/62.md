---
name: Optimize queries and add comprehensive error handling
status: closed
created: 2026-01-12T07:14:18Z
updated: 2026-01-12T07:24:05Z
completed: 2026-01-12T09:12:16Z
github: https://github.com/PATCoder97/fhs-prosight/issues/62
depends_on: [61]
parallel: true
conflicts_with: []
---

# Task: Optimize queries and add comprehensive error handling

## Description
Optimize database queries for performance, verify indexes are being used, and enhance error handling across all components. Add comprehensive logging for debugging and monitoring.

## Acceptance Criteria
- [ ] Database query optimization verified with EXPLAIN ANALYZE
- [ ] Indexes confirmed in use for search queries
- [ ] N+1 query problems eliminated
- [ ] Comprehensive error handling in all service functions
- [ ] Detailed logging for debugging (request/response, errors, performance)
- [ ] API key never logged or exposed in responses
- [ ] User-friendly error messages for all error scenarios
- [ ] Rate limit handling for PIDKey.com API (429 responses)

## Technical Details

### 1. Query Optimization

**Verify indexes are used:**
```sql
-- Test search query performance
EXPLAIN ANALYZE
SELECT * FROM pidms_keys
WHERE prd ILIKE '%Office%'
  AND remaining >= 100
  AND blocked = -1
ORDER BY prd, remaining DESC
LIMIT 50 OFFSET 0;

-- Should show:
-- - Index Scan on idx_pidms_keys_prd
-- - Index Scan on idx_pidms_keys_remaining
-- - Index Scan on idx_pidms_keys_blocked
-- - Execution time < 100ms for 10,000 rows
```

**Optimize upsert logic:**
```python
# Current: Individual SELECT for each key (N+1 problem)
# Optimized: Bulk query all keys at once

async def check_and_upsert_keys(db, keys_list, pidkey_client):
    # Call API
    api_response = await pidkey_client.check_keys(keys_list)

    # Bulk fetch existing keys (OPTIMIZED)
    keynames = [data["keyname"] for data in api_response]
    stmt = select(PIDMSKey).where(PIDMSKey.keyname.in_(keynames))
    result = await db.execute(stmt)
    existing_keys = {key.keyname: key for key in result.scalars().all()}

    # Separate into inserts vs updates
    new_keys = []
    for key_data in api_response:
        keyname = key_data["keyname"]
        if keyname in existing_keys:
            # UPDATE
            existing_key = existing_keys[keyname]
            for field, value in key_data.items():
                setattr(existing_key, field, value)
        else:
            # INSERT
            new_keys.append(PIDMSKey(**key_data))

    # Bulk insert
    if new_keys:
        db.add_all(new_keys)

    await db.commit()
```

### 2. Comprehensive Error Handling

**Service Layer:**
```python
async def check_and_upsert_keys(db, keys_list, pidkey_client):
    try:
        # Validate input
        if not keys_list:
            raise ValueError("No keys provided")

        if len(keys_list) > 50:
            raise ValueError("Maximum 50 keys per request")

        # Call API with detailed error handling
        try:
            api_response = await pidkey_client.check_keys(keys_list)
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 429:
                raise HTTPException(
                    status_code=503,
                    detail="PIDKey.com API rate limit exceeded. Please try again later."
                )
            elif e.response.status_code == 401:
                raise HTTPException(
                    status_code=500,
                    detail="Invalid PIDKey.com API key. Please check configuration."
                )
            else:
                raise HTTPException(
                    status_code=502,
                    detail=f"PIDKey.com API error: {e.response.status_code}"
                )
        except httpx.TimeoutException:
            raise HTTPException(
                status_code=504,
                detail="PIDKey.com API timeout. Please try again."
            )
        except Exception as e:
            logger.error(f"PIDKey API call failed: {e}", exc_info=True)
            raise HTTPException(
                status_code=500,
                detail="Failed to communicate with PIDKey.com API"
            )

        # Database operations with rollback
        try:
            # ... upsert logic ...
            await db.commit()
        except Exception as e:
            await db.rollback()
            logger.error(f"Database operation failed: {e}", exc_info=True)
            raise HTTPException(
                status_code=500,
                detail="Database error during key import"
            )

    except HTTPException:
        raise  # Re-raise HTTP exceptions
    except Exception as e:
        logger.error(f"Unexpected error in check_and_upsert_keys: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail="Internal server error"
        )
```

### 3. Comprehensive Logging

**Add structured logging:**
```python
import logging
import time

logger = logging.getLogger(__name__)

async def check_and_upsert_keys(db, keys_list, pidkey_client):
    start_time = time.time()

    logger.info(f"Starting key check for {len(keys_list)} keys")

    try:
        # API call
        api_start = time.time()
        api_response = await pidkey_client.check_keys(keys_list)
        api_duration = time.time() - api_start

        logger.info(
            f"PIDKey.com API call completed in {api_duration:.2f}s, "
            f"returned {len(api_response)} results"
        )

        # Database operations
        db_start = time.time()
        # ... upsert logic ...
        await db.commit()
        db_duration = time.time() - db_start

        total_duration = time.time() - start_time

        logger.info(
            f"Key check completed: {new_keys} new, {updated_keys} updated, "
            f"{error_count} errors. Total time: {total_duration:.2f}s "
            f"(API: {api_duration:.2f}s, DB: {db_duration:.2f}s)"
        )

        return result

    except Exception as e:
        duration = time.time() - start_time
        logger.error(
            f"Key check failed after {duration:.2f}s: {e}",
            exc_info=True,
            extra={
                "keys_count": len(keys_list),
                "error_type": type(e).__name__
            }
        )
        raise
```

**Security: Never log API key:**
```python
# WRONG - API key exposed in logs
logger.info(f"Calling PIDKey.com with API key: {self.api_key}")

# CORRECT - API key masked
logger.info(f"Calling PIDKey.com API (key: {self.api_key[:8]}***)")
```

### 4. Rate Limit Handling

**PIDKey Client:**
```python
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

class RateLimitError(Exception):
    pass

class PIDKeyClient:
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=2, min=4, max=30),
        retry=retry_if_exception_type(httpx.TimeoutException),
        reraise=True
    )
    async def check_keys(self, keys: List[str]) -> List[Dict]:
        try:
            # ... API call ...

            if resp.status_code == 429:
                retry_after = resp.headers.get("Retry-After", 60)
                logger.warning(f"Rate limited by PIDKey.com, retry after {retry_after}s")
                raise RateLimitError(f"Rate limited, retry after {retry_after}s")

            # ... rest of logic ...

        except RateLimitError:
            # Don't retry rate limits
            raise
```

**Files Affected:**
- `backend/app/services/pidms_service.py` (update error handling and logging)
- `backend/app/integrations/pidkey_client.py` (update error handling and rate limits)

## Dependencies
- [x] Task 008: Testing must be complete to identify optimization needs

## Effort Estimate
- Size: M
- Hours: 4-5 hours
- Parallel: true (can work independently)

## Definition of Done
- [x] Query optimization verified with EXPLAIN ANALYZE
- [x] Bulk query optimization implemented (no N+1)
- [x] All error scenarios have specific handling
- [x] Logging implemented throughout
- [x] API key security verified (never logged)
- [x] Rate limit handling tested
- [x] Performance benchmarks still met after changes
