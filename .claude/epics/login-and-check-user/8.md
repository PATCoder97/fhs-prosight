---
name: Viết integration tests và E2E test plan
status: open
created: 2026-01-08T02:23:12Z
updated: 2026-01-08T02:35:16Z
github: https://github.com/PATCoder97/fhs-prosight/issues/8
depends_on: [7]
parallel: true
conflicts_with: []
---

# Task: Viết integration tests và E2E test plan

## Description

Tạo integration tests và E2E test plan để verify:
1. Full OAuth flows (Google + GitHub) end-to-end
2. Admin workflows (assign localId → user re-login → verify token)
3. Multiple users có cùng localId scenario
4. Performance requirements (OAuth < 2s, token validation < 100ms)
5. Security aspects (role checks, authorization)

Integration tests sẽ mock OAuth APIs nhưng test real database operations.
E2E tests sẽ là manual test plan cho staging environment.

## Acceptance Criteria

- [ ] Integration test file `tests/integration/test_oauth_flow.py` created
- [ ] Integration test file `tests/integration/test_admin_workflow.py` created
- [ ] E2E test plan document created (`docs/e2e-test-plan.md`)
- [ ] Integration tests pass
- [ ] Mock OAuth APIs properly (không call real Google/GitHub)
- [ ] Tests cover all critical user journeys
- [ ] Performance tests included
- [ ] E2E test plan có step-by-step instructions

## Technical Details

### Integration Test 1: OAuth Flow

**File:** `tests/integration/test_oauth_flow.py`

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app
from unittest.mock import patch, MagicMock

client = TestClient(app)

@pytest.mark.integration
@patch('app.integrations.google_auth_client.GoogleAuthClient.get_user_info')
async def test_google_oauth_new_user(mock_get_user_info):
    """Test complete Google OAuth flow for new user"""

    # Mock Google API response
    mock_get_user_info.return_value = {
        "sub": "google123",
        "email": "newuser@gmail.com",
        "name": "New User",
        "picture": "https://avatar.url"
    }

    # Simulate OAuth callback
    response = client.get("/auth/google/callback?code=mock_code&state=mock_state")

    assert response.status_code == 200
    data = response.json()

    # Verify response structure
    assert "access_token" in data
    assert "user" in data

    # Verify user data
    user = data["user"]
    assert user["email"] == "newuser@gmail.com"
    assert user["role"] == "guest"  # NEW users get 'guest'
    assert user["localId"] is None
    assert user["provider"] == "google"

    # Verify JWT token
    token = data["access_token"]
    payload = verify_token(token, required_scope="access")

    assert payload["role"] == "guest"
    assert payload["localId"] is None
    assert payload["oauth_provider"] == "google"


@pytest.mark.integration
@patch('app.integrations.github_auth_client.GitHubAuthClient.get_user_info')
async def test_github_oauth_existing_user(mock_get_user_info):
    """Test GitHub OAuth for existing user with localId"""

    # Setup: Create existing user in DB
    async with AsyncSessionLocal() as db:
        existing_user = User(
            social_id="github456",
            provider="github",
            email="existing@github.com",
            full_name="Existing User",
            role="user",
            localId="VNW001"
        )
        db.add(existing_user)
        await db.commit()

    # Mock GitHub API response
    mock_get_user_info.return_value = {
        "id": 456,
        "email": "existing@github.com",
        "name": "Existing User",
        "avatar_url": "https://avatar.url"
    }

    # Simulate OAuth callback
    response = client.get("/auth/github/callback?code=mock_code&state=mock_state")

    assert response.status_code == 200
    data = response.json()

    # Verify existing user data preserved
    user = data["user"]
    assert user["role"] == "user"  # NOT 'guest'
    assert user["localId"] == "VNW001"
    assert user["provider"] == "github"

    # Verify JWT token
    token = data["access_token"]
    payload = verify_token(token, required_scope="access")

    assert payload["role"] == "user"
    assert payload["localId"] == "VNW001"
    assert payload["oauth_provider"] == "github"


@pytest.mark.integration
async def test_multiple_oauth_accounts_same_localId():
    """Test same person using Google and GitHub (different OAuth accounts)"""

    # Create 2 users với cùng localId
    async with AsyncSessionLocal() as db:
        user1 = User(
            social_id="google123",
            provider="google",
            email="person@gmail.com",
            full_name="Person A",
            role="user",
            localId="VNW001"
        )
        user2 = User(
            social_id="github456",
            provider="github",
            email="person@github.com",
            full_name="Person A",
            role="user",
            localId="VNW001"
        )
        db.add_all([user1, user2])
        await db.commit()

    # Query users by localId
    async with AsyncSessionLocal() as db:
        stmt = select(User).where(User.localId == "VNW001")
        result = await db.execute(stmt)
        users = result.scalars().all()

    assert len(users) == 2
    assert users[0].localId == "VNW001"
    assert users[1].localId == "VNW001"
    assert users[0].provider != users[1].provider
```

### Integration Test 2: Admin Workflow

**File:** `tests/integration/test_admin_workflow.py`

```python
import pytest
from fastapi.testclient import TestClient

@pytest.mark.integration
async def test_admin_assign_localId_workflow():
    """
    Test complete workflow:
    1. User login → role='guest', localId=None
    2. Admin assigns localId
    3. User re-login → receives localId in token
    """

    # Step 1: New user logs in via Google
    mock_google_response = {
        "sub": "new123",
        "email": "newuser@gmail.com",
        "name": "New Employee",
        "picture": "https://avatar.url"
    }

    with patch('app.integrations.google_auth_client.GoogleAuthClient.get_user_info',
               return_value=mock_google_response):
        response = client.get("/auth/google/callback?code=mock&state=mock")

    assert response.status_code == 200
    first_login = response.json()
    assert first_login["user"]["role"] == "guest"
    assert first_login["user"]["localId"] is None

    user_id = first_login["user"]["id"]

    # Step 2: Admin assigns localId
    admin_token = get_admin_token()  # Helper function

    response = client.put(
        f"/users/{user_id}/localId",
        json={"localId": "VNW002"},
        headers={"Authorization": f"Bearer {admin_token}"}
    )

    assert response.status_code == 200
    assert response.json()["user"]["localId"] == "VNW002"

    # Step 3: User logs in again
    with patch('app.integrations.google_auth_client.GoogleAuthClient.get_user_info',
               return_value=mock_google_response):
        response = client.get("/auth/google/callback?code=mock2&state=mock2")

    assert response.status_code == 200
    second_login = response.json()
    assert second_login["user"]["localId"] == "VNW002"

    # Verify JWT token has localId
    token = second_login["access_token"]
    payload = verify_token(token, required_scope="access")
    assert payload["localId"] == "VNW002"


@pytest.mark.integration
async def test_admin_change_role_workflow():
    """
    Test workflow:
    1. User has role='guest'
    2. Admin changes to role='user'
    3. User re-login → has new permissions
    """

    # Setup: Create guest user
    async with AsyncSessionLocal() as db:
        guest_user = User(
            social_id="guest123",
            provider="google",
            email="guest@example.com",
            full_name="Guest User",
            role="guest"
        )
        db.add(guest_user)
        await db.commit()
        await db.refresh(guest_user)
        user_id = guest_user.id

    # Admin changes role
    admin_token = get_admin_token()

    response = client.put(
        f"/users/{user_id}/role",
        json={"role": "user"},
        headers={"Authorization": f"Bearer {admin_token}"}
    )

    assert response.status_code == 200
    assert response.json()["user"]["role"] == "user"

    # Verify user can now access protected endpoints
    # (guest couldn't, but user can)
    user_token = create_access_token(
        user_id=str(user_id),
        full_name="Guest User",
        role="user"
    )

    response = client.get(
        "/protected/user-only-endpoint",
        headers={"Authorization": f"Bearer {user_token}"}
    )

    assert response.status_code == 200  # Now allowed
```

### E2E Test Plan

**File:** `docs/e2e-test-plan.md`

```markdown
# E2E Test Plan - Login and Check User

## Prerequisites
- Staging environment deployed
- Test accounts:
  - Google account: test@example.com
  - GitHub account: testuser
  - Admin account with role='admin'
- Database accessible
- Postman/curl for API testing

## Test Scenarios

### Scenario 1: New User Google Login

**Steps:**
1. Navigate to `/auth/login/google`
2. Authenticate with Google account (test@example.com)
3. Get redirected to callback with JWT token

**Expected Results:**
- [ ] Response status: 200 OK
- [ ] Response has `access_token` field
- [ ] `user.role` = "guest"
- [ ] `user.localId` = null
- [ ] `user.provider` = "google"
- [ ] JWT token decodes successfully
- [ ] Token payload has `oauth_provider` = "google"

**SQL Verification:**
```sql
SELECT * FROM users WHERE email = 'test@example.com';
-- Expected: role='guest', localId=NULL, provider='google'
```

### Scenario 2: Assign LocalId

**Steps:**
1. Login as admin
2. Get user_id from Scenario 1
3. Call `PUT /users/{user_id}/localId` with body: `{"localId": "VNW001"}`

**Expected Results:**
- [ ] Response status: 200 OK
- [ ] `user.localId` = "VNW001"
- [ ] Success message returned

**SQL Verification:**
```sql
SELECT localId FROM users WHERE email = 'test@example.com';
-- Expected: VNW001
```

### Scenario 3: User Re-Login After LocalId Assignment

**Steps:**
1. User from Scenario 1 logs out
2. Logs in again via Google
3. Check JWT token

**Expected Results:**
- [ ] `user.localId` = "VNW001"
- [ ] Token payload has `localId` = "VNW001"
- [ ] `user.role` still "guest"

### Scenario 4: Admin Changes Role

**Steps:**
1. Admin calls `PUT /users/{user_id}/role` with body: `{"role": "user"}`
2. User re-logs in

**Expected Results:**
- [ ] Response status: 200 OK
- [ ] User's new token has `role` = "user"
- [ ] User can now access `/protected/user-endpoints`

### Scenario 5: GitHub Login for Same Person

**Steps:**
1. Same person logs in via GitHub (different OAuth account)
2. Admin assigns same localId "VNW001"

**Expected Results:**
- [ ] New user record created (different provider)
- [ ] Both users have `localId` = "VNW001"
- [ ] Query by localId returns 2 users

**SQL Verification:**
```sql
SELECT * FROM users WHERE localId = 'VNW001';
-- Expected: 2 rows, different providers
```

### Scenario 6: Performance Testing

**Steps:**
1. Measure OAuth callback response time
2. Measure JWT token validation time

**Expected Results:**
- [ ] OAuth flow < 2s (p95)
- [ ] Token validation < 100ms (p99)

**Tools:** Apache Bench, Postman, or custom script

### Scenario 7: Security Testing

**Steps:**
1. Non-admin user tries to call `PUT /users/{id}/localId`
2. User tries to assign invalid localId (special chars)
3. User tries to set invalid role

**Expected Results:**
- [ ] Non-admin gets 403 Forbidden
- [ ] Invalid localId gets 422 Validation Error
- [ ] Invalid role gets 422 Validation Error

## Rollback Testing

**Steps:**
1. Backup database
2. Run migration rollback: `alembic downgrade -1`
3. Verify schema reverted

**Expected Results:**
- [ ] `localId` column dropped
- [ ] Role default back to 'user'
- [ ] No data loss
- [ ] Can re-run upgrade successfully
```

## Dependencies

- [x] Task 006 completed (unit tests passing)
- [ ] Test environment setup (staging)
- [ ] Mock OAuth API libraries
- [ ] Performance testing tools

## Effort Estimate

- **Size:** M (Medium)
- **Hours:** 4-5 hours
  - 2h: OAuth flow integration tests
  - 1.5h: Admin workflow integration tests
  - 1.5h: E2E test plan documentation
- **Parallel:** true (có thể làm song song với task khác)

## Definition of Done

- [ ] Integration tests created và pass
- [ ] OAuth APIs mocked properly
- [ ] All critical workflows tested
- [ ] E2E test plan documented với step-by-step
- [ ] Performance tests included
- [ ] Security tests included
- [ ] Ready for staging deployment (Task 008)
