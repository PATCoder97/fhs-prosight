---
name: Update User model và auth service cho localId support
status: open
created: 2026-01-08T02:23:12Z
updated: 2026-01-08T02:35:16Z
github: https://github.com/PATCoder97/fhs-prosight/issues/3
depends_on: [2]
parallel: false
conflicts_with: [4, 5]
---

# Task: Update User model và auth service cho localId support

## Description

Cập nhật User model và auth service để hỗ trợ field `localId`:
1. Thêm field `localId` vào SQLAlchemy User model
2. Update `get_or_create_user()` function để handle localId
3. Thay đổi default role từ `"user"` sang `"guest"` khi tạo user mới
4. Đảm bảo function trả về localId trong response dict

Task này phụ thuộc vào Task 001 (migration) vì cần có column `localId` trong database trước.

## Acceptance Criteria

- [ ] User model (`backend/app/models/user.py`) có field `localId = Column(String(50), nullable=True, index=True)`
- [ ] Default value của `role` trong model là `"guest"` (không còn `"user"`)
- [ ] `get_or_create_user()` function trả về `localId` trong dict
- [ ] Khi tạo user mới, `localId` được set thành `None`
- [ ] Khi get existing user, `localId` được lấy từ DB
- [ ] Function vẫn backward compatible với existing users (role không bị force change)
- [ ] Code không có breaking changes, existing auth flow vẫn hoạt động

## Technical Details

### Files to Modify

**1. `backend/app/models/user.py`**

Thêm field `localId`:
```python
class User(Base):
    __tablename__ = "users"

    # ... existing fields ...

    # NEW: LocalId for employee identification
    localId = Column(String(50), nullable=True, index=True)

    # UPDATED: Change default role
    role = Column(String(50), default="guest", nullable=False)  # Changed from "user"

    # ... rest of fields ...
```

**2. `backend/app/services/auth_service.py`**

Update `get_or_create_user()`:
```python
async def get_or_create_user(social_id: str, provider: str, email: str, full_name: str, avatar: str) -> dict:
    """Get existing user or create new one"""
    try:
        async with AsyncSessionLocal() as db:
            # Check if user exists
            stmt = select(User).where(
                (User.social_id == social_id) & (User.provider == provider)
            )
            result = await db.execute(stmt)
            user = result.scalars().first()

            if user:
                # Update last_login
                user.last_login = datetime.utcnow()
                await db.commit()
                await db.refresh(user)
                return {
                    "id": user.id,
                    "social_id": user.social_id,
                    "provider": user.provider,
                    "email": user.email,
                    "full_name": user.full_name,
                    "avatar": user.avatar,
                    "role": user.role,
                    "localId": user.localId,  # NEW: Include localId
                    "is_active": user.is_active,
                    "is_verified": user.is_verified,
                }

            # Create new user
            new_user = User(
                social_id=social_id,
                provider=provider,
                email=email,
                full_name=full_name,
                avatar=avatar,
                role="guest",  # CHANGED: from "user" to "guest"
                localId=None,   # NEW: Default to None
                is_active=True,
                is_verified=False,
            )
            db.add(new_user)
            await db.commit()
            await db.refresh(new_user)
            return {
                "id": new_user.id,
                "social_id": new_user.social_id,
                "provider": new_user.provider,
                "email": new_user.email,
                "full_name": new_user.full_name,
                "avatar": new_user.avatar,
                "role": new_user.role,
                "localId": new_user.localId,  # NEW: Include localId
                "is_active": new_user.is_active,
                "is_verified": new_user.is_verified,
            }
    except Exception as e:
        # Fallback (same as before but with localId)
        print(f"Database error: {e}. Using fallback user creation.")
        return {
            "id": 0,
            "social_id": social_id,
            "provider": provider,
            "email": email,
            "full_name": full_name,
            "avatar": avatar,
            "role": "guest",  # CHANGED
            "localId": None,   # NEW
            "is_active": True,
            "is_verified": False,
        }
```

### Key Considerations

1. **Backward Compatibility:**
   - Existing users trong DB sẽ có `localId = NULL` sau migration
   - Không force update existing users' role
   - Function vẫn return đúng format như cũ, chỉ thêm 1 field

2. **Default Values:**
   - New users: `role = "guest"`, `localId = None`
   - Existing users: Keep current role, `localId = NULL` (từ migration)

3. **Error Handling:**
   - Fallback case cũng phải include `localId` và role `"guest"`

## Dependencies

- [x] Task 001 completed (migration đã chạy, column localId đã tồn tại)
- [ ] Database schema có column `localId`
- [ ] SQLAlchemy và async session working properly

## Effort Estimate

- **Size:** S (Small)
- **Hours:** 2-3 hours
  - 0.5h: Update User model
  - 1h: Update `get_or_create_user()` function
  - 0.5h: Test với local database
  - 0.5h: Verify backward compatibility
  - 0.5h: Code review và cleanup
- **Parallel:** false (depends on Task 001, conflicts với 003, 004 vì cùng modify auth service)

## Definition of Done

- [ ] User model có field `localId`
- [ ] Default role trong model = `"guest"`
- [ ] `get_or_create_user()` function updated
- [ ] Function return dict có field `localId`
- [ ] Tested trên local: create new user → role = "guest", localId = None
- [ ] Tested: existing user login → nhận đúng role và localId từ DB
- [ ] No breaking changes - existing users vẫn login được
- [ ] Code formatted và có comments
- [ ] Ready to integrate với JWT handler (Task 003)
